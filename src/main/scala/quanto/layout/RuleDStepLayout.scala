package quanto.layout

import quanto.data.{DStep, Graph, VName}

import scala.collection.mutable
import breeze.linalg

/// Implements DStepLayoutStrategy which uses the layouts from each Rule to compute the layout of a Derivation.
class RuleDStepLayoutStrategy extends DStepLayoutStrategy {
  var step : DStep = null
  var root : Graph = null

  var automaticVertexSeparationEnabled : Boolean = true

  // Cache of the optimal affine transformation for the pair (step, root) above.
  var affineTransform : Option[((Double, Double)) => (Double, Double)] = null

  /// Provide a DStep for which the layout can be computed with DStepLayoutStrategy.layout().
  /// @param step the DStep that is to be laid out
  /// @param sourceGraph the source graph of the derivation step
  def setStep(step : DStep, root : Graph) : Unit = {
    this.step = step
    this.root = root
    this.affineTransform = null // Clear the cached optimal affine transformation.
  }

  /// Set whether to automatically separate vertices in the output with equal coordinates. When the matching algorithm matches a subgraph of the source graph with a rule containing !-boxes, the vertices generated by expanding the !-box are all placed with equal coordinates. This layout is then copied into the target diagram. 
  /// @param enabled true to enable this behaviour
  def setAutomaticVertexSeparation(enabled : Boolean) : Unit = {
    automaticVertexSeparationEnabled = enabled
  }

  /// Compute affineTransform for the present values of (step, root).
  private[this] def computeAffineTransform() : Unit = {
    this.affineTransform = null
    // Compare the layout of the LHS of the rule applied with the layout of the match in the source (matched) graph. Compute the optimal affine transformation that minimises the sum of squared distance between each vertex of the LHS of the rule and its match in the source graph. The thesis contains a derivation of the below method.
    val verts = (step.rule.lhs.verts intersect root.verts).toArray // The vertices need to be in a consistent order for the following numerical computations, which read coordinates elementwise.
    if (verts.size == 0) {
      // If there are no vertices to transform, don't bother.
      this.affineTransform = None
    }
    else if (verts.size == 1) {
      // Translate only.
      // Don't bother with least-squares optimisation here. Just pick the first vertex.
      val v = verts.head
      val (x1, y1) = root.vdata(v).coord
      val (x0, y0) = step.rule.lhs.vdata(v).coord
      this.affineTransform = Some(RuleDStepLayoutStrategy.affineTransform(1.0, 0.0, 0.0, 1.0, x1 - x0, y1 - y0))
    }
    else if (verts.size >= 2) {
      // The optimisation is expressed in terms of linear algebra. See the thesis for a derivation.
      val nverts : Double = verts.size.toDouble
      val Wx : linalg.DenseVector[Double] = linalg.DenseVector(verts.map(v => step.rule.lhs.vdata(v).coord._1))
      val Wy : linalg.DenseVector[Double] = linalg.DenseVector(verts.map(v => step.rule.lhs.vdata(v).coord._2))
      val Zx : linalg.DenseVector[Double] = linalg.DenseVector(verts.map(v => root.vdata(v).coord._1))
      val Zy : linalg.DenseVector[Double] = linalg.DenseVector(verts.map(v => root.vdata(v).coord._2))
      val sumWx : Double = linalg.sum(Wx)
      val sumWy : Double = linalg.sum(Wy)
      val sumZx : Double = linalg.sum(Zx)
      val sumZy : Double = linalg.sum(Zy)
      val sumWxWx : Double = Wx.dot(Wx)
      val sumWyWy : Double = Wy.dot(Wy)
      val sumWxZx : Double = Wx.dot(Zx)
      val sumWxZy : Double = Wx.dot(Zy)
      val sumWyZx : Double = Wy.dot(Zx)
      val sumWyZy : Double = Wy.dot(Zy)
      if (verts.size >= 3) {
        // Fully generic affine transformation.
        val sumWxWy : Double = Wx.dot(Wy)
        val matrix : linalg.DenseMatrix[Double] = linalg.DenseMatrix(List(sumWxWx, sumWxWy, sumWx),
                                                                     List(sumWxWy, sumWyWy, sumWy),
                                                                     List(sumWx, sumWy, nverts))
        val matchVector1 : linalg.DenseVector[Double] = linalg.DenseVector[Double](sumWxZx, sumWyZx, sumZx)
        val matchVector2 : linalg.DenseVector[Double] = linalg.DenseVector[Double](sumWxZy, sumWyZy, sumZy)
        try {
          val output1 : linalg.DenseVector[Double] = matrix \ matchVector1 // a, b, e
          val output2 : linalg.DenseVector[Double] = matrix \ matchVector2 // c, d, f
          this.affineTransform = Some(RuleDStepLayoutStrategy.affineTransform(output1(0), output1(1), output2(0), output2(1), output1(2), output2(2)))
        } catch {
          case _ : linalg.MatrixSingularException => {}
        }
      }
      if (this.affineTransform == null) {
        // Scale, rotate, and translate only (i.e. [[a, b], [-b, a]] @ w + [e, f]).
        val matrix : linalg.DenseMatrix[Double] = linalg.DenseMatrix(List(sumWxWx + sumWyWy, 0.0, sumWx, sumWy),
                                                                     List(0.0, sumWxWx + sumWyWy, sumWy, -sumWx),
                                                                     List(sumWx, sumWy, nverts, 0.0),
                                                                     List(sumWy, -sumWx, 0.0, nverts))
        val vector : linalg.DenseVector[Double] = linalg.DenseVector[Double](sumWxZx + sumWyZy, sumWyZx - sumWxZy, sumZx, sumZy)
        try {
          val output : linalg.DenseVector[Double] = matrix \ vector // a, b, e, f
          this.affineTransform = Some(RuleDStepLayoutStrategy.affineTransform(output(0), output(1), -output(1), output(0), output(2), output(3)))
        } catch {
          case _ : linalg.MatrixSingularException => {}
        }
      }
      if (this.affineTransform == null) {
        // Scale and translate only (i.e. [[a, 0], [0, a]] @ w + [e, f]).
        val matrix : linalg.DenseMatrix[Double] = linalg.DenseMatrix(List(sumWxWx + sumWyWy, sumWx, sumWy),
                                                                     List(sumWx, nverts, 0.0),
                                                                     List(sumWy, 0.0, nverts))
        val vector : linalg.DenseVector[Double] = linalg.DenseVector[Double](sumWxZx + sumWyZy, sumZx, sumZy)
        try {
          val output : linalg.DenseVector[Double] = matrix \ vector // a, e, f
          this.affineTransform = Some(RuleDStepLayoutStrategy.affineTransform(output(0), 0.0, 0.0, output(0), output(1), output(2)))
        } catch {
          case _ : linalg.MatrixSingularException => {}
        }
      }
      if (this.affineTransform == null) {
        // Translate only (i.e. [[1, 0], [0, 1]] @ w + [e, f]).
        // This least-squares minimisation has a simple form: the mean.
        // This is guaranteed to successfuly produce an affine transformation.
        this.affineTransform = Some(RuleDStepLayoutStrategy.affineTransform(1.0, 0.0, 0.0, 1.0, sumZx / nverts, sumZy / nverts))
      }
    }
  }

  /// Post-process a set of coordinates and the vertices to separate vertices with the same coordinates.
  private[this] def separateVerticesAutomatically(graph : Graph, coords : mutable.HashMap[VName, (Double, Double)]) : mutable.HashMap[VName, (Double, Double)] = {
    // Invert the coords map to find vertices with the same coordinates.
    val vertsAt = new mutable.HashMap[(Double, Double), mutable.HashSet[VName]]()
    for ((vert, coord) <- coords) {
      if (!vertsAt.contains(coord)) {
        vertsAt(coord) = new mutable.HashSet[VName]()
      }
      vertsAt(coord) += vert
    }
    // Separate the vertices.
    val layout = new RuleGraphLayoutData(graph, coords)
    val newCoords = new mutable.HashMap[VName, (Double, Double)]()
    newCoords ++= coords
    for ((coord, verts) <- vertsAt) {
      // Skip vertices which have unique coordinates.
      if (verts.size > 1) {
        // Calculate the adjacent vertices of each vertex (which do not share the coordinate), and the least distance to each such adjacent vertex.
        for (vert <- verts) {
          // Calculate the adjacent vertices of each vertex (which do not share the coordinate).
          val adjacents = graph.adjacentVerts(vert) &~ verts
          // Calculate the least distances and cumulative distances to each adjacent vertex.
          var leastSqrDistance : Option[Double] = None
          var sdx = 0.0
          var sdy = 0.0
          for (adjVert <- adjacents) {
            val dx = coord._1 - layout.getCoords(adjVert)._1
            val dy = coord._2 - layout.getCoords(adjVert)._2
            sdx += dx
            sdy += dy
            val sqrDistance = dx * dx + dy * dy
            if (leastSqrDistance.isEmpty || sqrDistance < leastSqrDistance.get) {
              leastSqrDistance = Some(sqrDistance)
            }
          }
          if (!leastSqrDistance.isEmpty) {
            // Move each vertex towards its adjacent vertices by at most 1/3 of the minimum distance to each such adjacent vertex.
            val moveDistance = scala.math.sqrt(leastSqrDistance.get) / 3.0
            val scaleFactor = moveDistance / scala.math.sqrt(sdx * sdx + sdy * sdy)
            val changeLimit = moveDistance * 60.0
            newCoords(vert) = (coord._1 + (((sdx * scaleFactor) min changeLimit) max (-changeLimit)), coord._2 + (((sdy * scaleFactor) min changeLimit) max (-changeLimit)))
          }
        }
      }
    }
    return newCoords
  }

  /// Create a RuleGraphLayoutData object containing the layout data for the output of the DStep.
  /// The DStep and source graph must have been previously provided to the RuleDStepLayoutStrategy (by constructing with the data or by calling RuleDStepLayoutStrategy.setStep).
  /// @return a RuleGraphLayoutData containing the layout data for the output of the DStep.
  def layoutOutput() : GraphLayoutData = {
    // Compute the affine transformation, if not already computed.
    if (affineTransform == null) {
      computeAffineTransform()
    }
    // Apply the affine transformation to the inclusion of the rule's RHS inside the target (generated) graph.
    var newCoords = new mutable.HashMap[VName, (Double, Double)]()
    if (!affineTransform.isEmpty) {
      val affineTransform = this.affineTransform.get
      for (v <- (step.rule.rhs.verts intersect step.graph.verts)) {
        newCoords(v) = affineTransform(step.rule.rhs.vdata(v).coord)
      }
    }
    // Apply automatic vertex separation, if enabled.
    if (this.automaticVertexSeparationEnabled) {
      newCoords = separateVerticesAutomatically(step.graph, newCoords)
    }
    return new RuleGraphLayoutData(step.graph, newCoords)
  }

  /// Create a RuleGraphLayoutData object containing the layout data for the source graph.
  /// The DStep and source graph must have been previously provided to the RuleDStepLayoutStrategy (by constructing with the data or by calling RuleDStepLayoutStrategy.setStep).
  /// @return a RuleGraphLayoutData containing the layout data for the source graph.
  def layoutSource() : GraphLayoutData = {
    // Compute the affine transformation, if not already computed.
    if (affineTransform == null) {
      computeAffineTransform()
    }
    // Apply the affine transformation to the inclusion of the rule's LHS inside the source (matched) graph.
    var newCoords = new mutable.HashMap[VName, (Double, Double)]()
    if (!affineTransform.isEmpty) {
      val affineTransform = this.affineTransform.get
      for (v <- (step.rule.lhs.verts intersect root.verts)) {
        newCoords(v) = affineTransform(step.rule.lhs.vdata(v).coord)
      }
    }
    // Apply automatic vertex separation, if enabled.
    if (this.automaticVertexSeparationEnabled) {
      newCoords = separateVerticesAutomatically(root, newCoords)
    }
    return new RuleGraphLayoutData(root, newCoords)
  }
}

/// Implements a RuleGraphLayout which uses the layouts from each Rule to compute the layout of a Graph.
class RuleGraphLayoutData private[this] extends GraphLayoutData {
  private[this] var _graph : Graph = null;
  private[this] var coords : mutable.Map[VName, (Double, Double)] = null;

  /// Not part of the public interface. Constructs a RuleDerivationLayout.
  private[layout] def this(graph : Graph, coords : mutable.Map[VName, (Double, Double)]) = {
    this()
    this._graph = graph
    this.coords = coords
  }

  /// Get the layout's coordinates for the vertex named v.
  /// @param v the name of the vertex in the graph selected by dso
  /// @return the layout's coordinates for the queried vertex.
  def getCoords(v: VName) : (Double, Double) = {
    return coords.getOrElse(v, _graph.vdata(v).coord) // Unset coordinates remain as-is.
  }

  /// The original Graph, with the previous layout, that this layout was computed for.
  def graph : Graph = {
    return _graph
  }
}

object RuleDStepLayoutStrategy {
  /// Compute the 2D affine transformation:
  /// [a b]           [e]
  /// [c d] @ coord + [f]
  /// @param a, b, c, d, e, f affine transformation entries as above
  /// @return pair of values equal to above equation
  def affineTransform(a : Double, b : Double, c : Double, d : Double, e : Double, f : Double)(coord : (Double, Double)) : (Double, Double) = {
    val x = coord._1
    val y = coord._2
    return (a * x + b * y + e, c * x + d * y + f)
  }
}
