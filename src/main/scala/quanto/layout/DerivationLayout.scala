package quanto.layout

import quanto.data.{Derivation, DSName, Graph, VName}

/// Builds a DerivationLayout object containing the computed layout for a derivation.
abstract class DerivationLayoutStrategy {
  /// Secondary constructor, which allows the Derivation to be provided at construction.
  def this(derivation : Derivation) {
    this();
    this.setDerivation(derivation)
  }

  /// Provide a Derivation for which the layout can be computed with DerivationLayoutStrategy.layout().
  /// @param derivation the Derivation that is to be laid out
  def setDerivation(derivation : Derivation) : Unit;

  /// Implementations may provide additional methods for setting parameters for the layout algorithm.
  /// Implementations may also provide additional constructors for setting parameters for the layout algorithm.

  /// Create an object of type DerivationLayout containing the data of the new derivation layout.
  /// A Derivation must have been previously provided to the DerivationLayoutStrategy (by constructing with a Derivation or by calling DerivationLayoutStrategy.setLayout).
  /// @return a DerivationLayout corresponding to the previously provided Derivation
  def layout() : DerivationLayout;
}

/// Represents the layout of all the graphs in a Derivation.
/// Users do not construct objects of this class directly, but use the DerivationLayoutStrategy instead.
abstract class DerivationLayout {
  /// Get the layout's coordinates for the vertex named v in: the root graph if dso is None, or the graph generated by derivation step ds if dso is Some(ds)
  /// @param dso None to query the root graph, otherwise the DSName of the DStep generating the graph to query
  /// @param v the name of the vertex in the graph selected by dso
  /// @return the layout's coordinates for the queried vertex.
  def getCoords(dso : Option[DSName], v: VName) : (Double, Double);

  /// The Derivation that this layout was computed for.
  def derivation : Derivation;

  /// Get a new Derivation exactly equal to the input, but having the layout from this DerivationLayout object. The Derivation that was computed on is not modified. This method is part of the trusted computing base.
  /// @return a new Derivation exactly equal to the input, but having the layout from this DerivationLayout object.
  final def asDerivation() : Derivation = {
    def asGraph(dso : Option[DSName], graph : Graph) : Graph = {
      var newGraph = graph
      // For each vertex in the graph, replace its coordinate with the new coordinate of the vertex.
      for (v <- graph.verts) {
        newGraph = newGraph.updateVData(v) { vd => vd.withCoord(getCoords(dso, v)) }
      }
      return newGraph
    }
    // Insert the new layout of the root graph.
    var newDerivation = derivation.copy(root = asGraph(None, derivation.root))
    // For each derivation step, insert the new layout of the graph generated by that derivation step.
    for (ds <- newDerivation.steps.keys) {
      newDerivation = newDerivation.updateGraphInStep(ds, asGraph(Some(ds), derivation.steps(ds).graph))
    }
    return newDerivation
  }
}
